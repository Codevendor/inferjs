var __webpack_require__={d:(exports,definition)=>{for(var key in definition)__webpack_require__.o(definition,key)&&!__webpack_require__.o(exports,key)&&Object.defineProperty(exports,key,{enumerable:!0,get:definition[key]})},o:(obj,prop)=>Object.prototype.hasOwnProperty.call(obj,prop),r:exports=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(exports,"__esModule",{value:!0})}},__webpack_exports__={};__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{InferExpectError:()=>InferExpectError,InferJS:()=>InferJS,InferTypeError:()=>InferTypeError,InferUnhandledError:()=>InferUnhandledError});const REG_PARSE_OBJECT_STRING=/\[{0,1}([^\s\]]+)\s{0,}([^\s\]]+)\]{0,1}/;function type_of(src,extended=!1){const srcType=typeof src;switch(srcType){case"undefined":return"undefined";case"string":return"string";case"number":return extended?isNaN(src)?"nan":src===1/0?"infinity":"number":"number";case"bigint":return"bigint";case"symbol":return"symbol";case"function":return extended&&src.name?src.name:"function";case"object":if(null==src)return"null";if(!extended)return"object";const m={}.toString.call(src).match(REG_PARSE_OBJECT_STRING);if(!m||3!==m.length)return"object";switch(m[2]=m[2].toLowerCase(),m[1]){case"string":return"stringobject";case"object":switch(m[2]){case"arguments":return"arguments";case"array":return"array";case"error":return src.constructor.name?src.constructor.name:"error";default:return src.constructor.name?src.constructor.name:"object"}default:return"object"}default:return"undefined"!=typeof window&&src===window?"window":srcType}}const simple=["zeroth","first","second","third","fourth","fifth","sixth","seventh","eighth","ninth","tenth","eleventh","twelvth","thirteenth","fourteenth","fifteenth","sixteenth","seventeenth","eighteenth","nineteenth"],deca=["twent","thirt","fourt","fift","sixt","sevent","eight","ninet"];function numberRepresent(src){if("number"!==type_of(src))throw new TypeError("Param (src) must be a number from 0 to 99!");if(src<0||src>99)throw new TypeError("Param (src) must be a number from 0 to 99!");return src<20?simple[src]:src%10==0?deca[Math.floor(src/10)-2]+"ieth":deca[Math.floor(src/10)-2]+"y-"+simple[src%10]}class InferExpectError extends Error{#inferObject=null;#paramPosition=0;#actualType="";#expectedType="";#paramPositionRepresent="";#method="";#inferId="";#methodSignature="";#param="";#inferExpectation="";#argValue="";#argValueSafe="";#inferExpectationValue="";#inferExpectationValueSafe="";get paramPosition(){return this.#paramPosition}get actualType(){return this.#actualType}get expectedType(){return this.#getExpectedType}get method(){return this.#method}get inferId(){return this.#inferId}get methodSignature(){return this.#methodSignature}get param(){return this.#param}get inferExpectation(){return this.#inferExpectation}get argValue(){return this.#argValue}get argValueSafe(){return this.#argValueSafe}get inferExpectationValue(){return this.#inferExpectationValue}get inferExpectationValueSafe(){return this.#inferExpectationValueSafe}get name(){return this.constructor.name}constructor(inferObject,paramIndex,actualType,inferExpectation,argValue,inferExpectationValue){super(),this.#inferExpectation=inferExpectation,this.#argValue=argValue,this.#argValueSafe=this.#convertArgToSafeString(argValue),this.#inferExpectationValue=inferExpectationValue,this.#inferExpectationValueSafe=this.#convertArgToSafeString(inferExpectationValue),this.#inferObject=inferObject,this.#paramPosition=paramIndex+1,this.#actualType=this.#getUniqueActualType(actualType,!0),this.#inferId=inferObject.hasOwnProperty("@inferid")?inferObject["@inferid"]:"Unknown",this.#paramPositionRepresent=numberRepresent(this.#paramPosition),this.#method=inferObject.hasOwnProperty("@function")?inferObject["@function"]:"",this.#methodSignature=this.#getMethodSignature(inferObject),this.#param=Object.keys(inferObject["@param"])[paramIndex],this.#expectedType=this.#getExpectedType(inferObject,this.#param,!0),this.message=`Incorrect ${this.#paramPositionRepresent} parameter, failed infer expectation type check in:\n@inferid: ${this.#inferId}\n@function: ${this.#methodSignature}\n@param: ${this.#param}\nExpectation Type: ${this.#inferExpectation}\n`+(this.#inferExpectationValueSafe?`Expectation Value: ${this.#inferExpectationValueSafe}\n`:"")+`Argument Value: ${this.#argValueSafe}`}#convertArgToSafeString(argValue){let safeString="";try{safeString=JSON.stringify(argValue)}catch(err){safeString="unknown"}return safeString}#getUniqueActualType(actualType,multiTypeParenthesis=!1){if(!actualType&&"string"!==type_of(actualType))return"unknown";const types=actualType.split("|").filter(((v,i,a)=>a.indexOf(v)==i)),typeString=types.join("|");return multiTypeParenthesis&&types.length>1?"("+typeString+")":typeString}#getExpectedType(inferObject,paramName,multiTypeParenthesis=!1){let eType="unknown";if(inferObject&&inferObject.hasOwnProperty("@param")&&inferObject["@param"].hasOwnProperty(paramName)&&inferObject["@param"][paramName].hasOwnProperty("types")){const types=inferObject["@param"][paramName].types,keys=Object.keys(types),keyString=keys.join("|");eType=multiTypeParenthesis&&keys.length>1?"("+keyString+")":keyString}return eType}#getMethodSignature(inferObject){let sig=inferObject.hasOwnProperty("@function")?inferObject["@function"]+"( ":"( ";if(inferObject.hasOwnProperty("@param")){const params=Object.keys(inferObject["@param"]);for(let i=0;i<params.length;i++){const paramName=params[i],param=inferObject["@param"][paramName];sig+=paramName+": "+(param.hasOwnProperty("types")?"<"+Object.keys(param.types).join("|")+">":"<any>")+", "}sig=sig.endsWith(", ")?sig.slice(0,-2):sig}return sig+=" )",sig}}class InferTypeError extends TypeError{#inferObject=null;#paramPosition=0;#actualType="";#expectedType="";#paramPositionRepresent="";#method="";#inferId="";#methodSignature="";#param="";get paramPosition(){return this.#paramPosition}get actualType(){return this.#actualType}get expectedType(){return this.#getExpectedType}get method(){return this.#method}get inferId(){return this.#inferId}get methodSignature(){return this.#methodSignature}get param(){return this.#param}get name(){return this.constructor.name}constructor(inferObject,paramIndex,actualType){super(),this.#inferObject=inferObject,this.#paramPosition=paramIndex+1,this.#actualType=this.#getUniqueActualType(actualType,!0),this.#inferId=inferObject.hasOwnProperty("@inferid")?inferObject["@inferid"]:"Unknown",this.#paramPositionRepresent=numberRepresent(this.#paramPosition),this.#method=inferObject.hasOwnProperty("@function")?inferObject["@function"]:"",this.#methodSignature=this.#getMethodSignature(inferObject),this.#param=Object.keys(inferObject["@param"])[paramIndex],this.#expectedType=this.#getExpectedType(inferObject,this.#param,!0),this.message=`Incorrect ${this.#paramPositionRepresent} parameter type in:\n@inferid: ${this.#inferId}\n@function: ${this.#methodSignature}\n@param: ${this.#param}\nExpected Type: ${this.#expectedType}\nActual Type: ${this.#actualType}`}#getUniqueActualType(actualType,multiTypeParenthesis=!1){if(!actualType&&"string"!==type_of(actualType))return"unknown";const types=actualType.split("|").filter(((v,i,a)=>a.indexOf(v)==i)),typeString=types.join("|");return multiTypeParenthesis&&types.length>1?"("+typeString+")":typeString}#getExpectedType(inferObject,paramName,multiTypeParenthesis=!1){let eType="unknown";if(inferObject&&inferObject.hasOwnProperty("@param")&&inferObject["@param"].hasOwnProperty(paramName)&&inferObject["@param"][paramName].hasOwnProperty("types")){const types=inferObject["@param"][paramName].types,keys=Object.keys(types),keyString=keys.join("|");eType=multiTypeParenthesis&&keys.length>1?"("+keyString+")":keyString}return eType}#getMethodSignature(inferObject){let sig=inferObject.hasOwnProperty("@function")?inferObject["@function"]+"( ":"( ";if(inferObject.hasOwnProperty("@param")){const params=Object.keys(inferObject["@param"]);for(let i=0;i<params.length;i++){const paramName=params[i],param=inferObject["@param"][paramName];sig+=paramName+": "+(param.hasOwnProperty("types")?"<"+Object.keys(param.types).join("|")+">":"<any>")+", "}sig=sig.endsWith(", ")?sig.slice(0,-2):sig}return sig+=" )",sig}}class InferUnhandledError extends Error{constructor(){super()}}function between(value,values,inclusive=!1){if("number"!==type_of(value))throw TypeError(`Incorrect Type for between(value: <${type_of(value)}>) expecting between(value: <number>)!`);if("array"!==type_of(values,!0))throw TypeError(`Incorrect Type for between(values: <${type_of(values)}>) expecting between(values: <array[number]>)!`);if(values.length<2)throw RangeError(`Incorrect range for between(values), length must be greater than 1. values.length = ${values.length}`);const min=Math.min(...values),max=Math.max(...values);return inclusive?value>=min&&value<=max:value>min&&value<max}function betweenBigInt(value,values,inclusive=!1){if("bigint"!==type_of(value))throw TypeError(`Incorrect Type for betweenBigInt(value: <${type_of(value)}>) expecting betweenBigInt(value: <bigint>)!`);if("array"!==type_of(values,!0))throw TypeError(`Incorrect Type for betweenBigInt(values: <${type_of(values)}>) expecting betweenBigInt(values: <array[bigint]>)!`);if(values.length<2)throw RangeError(`Incorrect range for betweenBigInt(values), length must be greater than 1. values.length = ${values.length}`);const min=(values=values.sort(((a,b)=>BigInt(a)>BigInt(b)?0:-1)))[0],max=values[values.length-1];return inclusive?value>=min&&value<=max:value>min&&value<max}const REG_IS_BIG_INT=/^|[\d]+n|^[\d]{17,}n{0,}$|^900719925474099[2-9]{1}$|^[\d]{0,}\.[\d]+e\+[\d]{0,}$/gim;function isBigInt(src){switch(type_of(src,!0)){case"bigint":return!0;case"string":if(""===(src=src.trim()))return!1;if(!REG_IS_BIG_INT.test(src))return!1;src.endsWith("n")&&(src=src.slice(0,-1));try{src=BigInt(src)}catch(err){return!1}return!0;default:return!1}}function isNumeric(src){switch(type_of(src,!0)){case"number":case"bigint":return!0;case"string":return!!isBigInt(src)||(src=src.trim(),!isNaN(parseFloat(src)));default:return!1}}const REG_ALPHA=new RegExp("^[a-zA-Z]+$"),REG_ALPHA_NUMERIC=new RegExp("^[a-zA-Z0-9]+$"),REG_NUMBER=new RegExp("^[+-]{0,1}[0-9]{1,}[.]{0,1}[0-9]{0,}[e]{0,1}[+-]{0,1}[0-9]{0,}$");function validate(method,value,evalue){if("string"!==type_of(method))throw TypeError(`Incorrect Type for validate(method: <${type_of(method)}>) expecting validate(method: <string>)!`);switch(method.toUpperCase()){case"UNDEFINED":return"undefined"===type_of(value);case"NULL":return"null"===type_of(value);case"SYMBOL":return"symbol"===type_of(value);case"BOOLEAN":return"boolean"===type_of(value);case"STRING":return"string"===type_of(value);case"NUMBER":return"number"===type_of(value);case"BIGINT":return"bigint"===type_of(value);case"ARRAY":return"array"===type_of(value);case"OBJECT":return"object"===type_of(value);case"STRING-NOT-EMPTY":return""!==value.toString().trim();case"STRING-EMPTY":return""===value.toString().trim();case"IS-BOOL":return-1!==function parseBool(src){switch(type_of(src)){case"boolean":return src;case"string":switch(src=src.trim().toUpperCase()){case"TRUE":case"1":case"YES":return!0;case"FALSE":case"0":case"NO":return!1;default:return-1}case"number":switch(src){case 0:return!1;case 1:return!0;default:return-1}default:return-1}}(value);case"BETWEEN":return between(value,evalue);case"BETWEEN-INCLUSIVE":return between(value,evalue,!0);case"BETWEEN-BIGINT":return betweenBigInt(value,evalue);case"BETWEEN-BIGINT-INCLUSIVE":return betweenBigInt(value,evalue,!0);case"GREATER-THAN":return parseInt(value)>parsent(evalue);case"GREATER-THAN-EQUAL":return parseInt(value)>=parsent(evalue);case"LESS-THAN":return parseInt(value)<parsent(evalue);case"LESS-THAN-EQUAL":return parseInt(value)<=parsent(evalue);case"REGEX":return new RegExp(evalue).test(value.toString());case"ALPHA":return REG_ALPHA.test(value.toString());case"IS-NUMBER":return REG_NUMBER.test(value.toString());case"IS-BIGINT":return isBigInt(value);case"IS-NUMERIC":return isNumeric(value);case"ALPHA-NUMERIC":return REG_ALPHA_NUMERIC.test(value.toString());case"IN-ARRAY-CI":evalue=evalue.join("|").toLowerCase().split("|"),value=value.toLowerCase();case"IN-ARRAY":return evalue.includes(value);case"NOT-IN-ARRAY-CI":evalue=evalue.join("|").toLowerCase().split("|"),value=value.toLowerCase();case"NOT-IN-ARRAY":return!evalue.includes(value);case"EXTENDS-ALL":if("object"!==type_of(value))return!1;Array.isArray(evalue)||(evalue=[evalue]);for(let i=0;i<evalue.length;i++)if(!(value instanceof evalue[i]))return!1;return!0;case"EXTENDS":if("object"!==type_of(value))return!1;Array.isArray(evalue)||(evalue=[evalue]);for(let i=0;i<evalue.length;i++)if(value instanceof evalue[i])return!0;return!1;case"PROPS":if("object"!==type_of(value))return!1;return Object.keys(value).forEach((key=>{if(!evalue.includes(key))return!1})),!0;case"ARRAY-NOT-EMPTY":return value.length>0;case"ARRAY-EMPTY":return 0===value.length;case"ARRAY-TYPES":return"string"===type_of(evalue)&&(evalue=[evalue]),value.forEach((item=>{evalue.forEach((item2=>{if(!validate(item2,item))return!1}))})),!0;case"CHAR":case"INT8":return!!isNumeric(value)&&(value=parseInt(value),!isNaN(value)&&!!between(value,[-128,127],!0));case"UNSIGNED-CHAR":case"UCHAR":case"UINT8":return!!isNumeric(value)&&(value=parseInt(value),!isNaN(value)&&!!between(value,[0,255],!0));case"SHORT":case"SHORT-INT":case"SIGNED-SHORT-INT":case"INT16":return!!isNumeric(value)&&(value=parseInt(value),!isNaN(value)&&!!between(value,[-32768,32767],!0));case"UNSIGNED-SHORT":case"UNSIGNED-SHORT-INT":case"USHORT":case"UINT16":return!!isNumeric(value)&&(value=parseInt(value),!isNaN(value)&&!!between(value,[0,65535],!0));case"SIGNED-INT":case"INT":case"INT32":return!!isNumeric(value)&&(value=parseInt(value),!isNaN(value)&&!!between(value,[-2147483648,2147483647],!0));case"UNSIGNED-INT":case"UINT":case"UINT32":return!!isNumeric(value)&&(value=parseInt(value),!isNaN(value)&&!!between(value,[0,4294967295],!0));case"SIGNED-LONG":case"SIGNED-LONG-LONG":case"LONG":case"LONG-LONG":case"INT64":return!!isNumeric(value)&&((value=value.toString()).endsWith("n")&&(value=value.slice(0,-1)),!!between(BigInt(value),[BigInt("-9223372036854775808"),BigInt("9223372036854775807")],!0));case"UNSIGNED-LONG":case"UNSIGNED-LONG-LONG":case"ULONG":case"UINT64":return!!isNumeric(value)&&((value=value.toString()).endsWith("n")&&(value=value.slice(0,-1)),!!between(BigInt(value),[BigInt("0"),BigInt("18446744073709551615")],!0));default:return!1}}class InferJS{#inferObject=null;get inferObject(){return this.#inferObject}set inferObject(value){this.#inferObject=value}constructor(){!function overload(src,methodName,args,removeOverloads=!1){if(src[`${methodName}${args.length}`](...args),removeOverloads)for(let i=0;i<args.length+1;i++){const name=`${methodName}${i}`;src[name]&&delete src[name]}}(this,"constructor",arguments,!0)}constructor1(inferObject){this.#inferObject=inferObject}check(inferId,src,returnException=!1){return"arguments"===type_of(src,!0)?this.#checkMethod(inferId,src,returnException):this.#checkVar(inferId,src,returnException)}#checkVar(inferId,src,returnException=!1){}#checkMethod(inferId,args,returnException=!1){if("object"!==type_of(this.#inferObject)||"object"!==type_of(this.#inferObject.infers)||!this.#inferObject.infers.hasOwnProperty(inferId)){const err=new TypeError(`Cannot find infer with inferid: ${inferId}`);if(returnException)throw err;return err}const inf=this.#inferObject.infers[inferId];if(inf.hasOwnProperty("@param")){const expectParams=Object.keys(inf["@param"]);for(let i=0;i<expectParams.length;i++){const argValue=args[i],paramName=expectParams[i],allowedTypes=inf["@param"][paramName].types,argType=type_of(argValue),argTypeExt=type_of(argValue,!0);if(!allowedTypes.hasOwnProperty(argType)&&!allowedTypes.hasOwnProperty(argTypeExt,!0)){if(returnException)throw new InferTypeError(inf,i,argType+"|"+argTypeExt);return new InferTypeError(inf,i,argType+"|"+argTypeExt)}const actualTypes=[argType,argTypeExt].filter(((v,i,a)=>a.indexOf(v)==i));for(let i2=0;i2<actualTypes.length;i2++){const actualType=actualTypes[i2];if(allowedTypes.hasOwnProperty(actualType)){const infers=allowedTypes[actualType].infers,infersArray=Object.keys(infers);for(let i3=0;i3<infersArray.length;i3++){const inferExpectation=infersArray[i3].toUpperCase(),inferExpectationValue=infers[inferExpectation].value,THROW=()=>{if(returnException)throw new InferExpectError(inf,i,argType+"|"+argTypeExt,inferExpectation,argValue,inferExpectationValue);return new InferExpectError(inf,i,argType+"|"+argTypeExt,inferExpectation,argValue,inferExpectationValue)};switch(inferExpectation){case"STRING-NOT-EMPTY":case"STRING-EMPTY":case"REGEX":case"ALPHA":case"IS-NUMBER":case"IS-BIGINT":case"IS-NUMERIC":case"ALPHA-NUMERIC":case"IN-ARRAY-CI":case"IN-ARRAY":case"NOT-IN-ARRAY-CI":case"NOT-IN-ARRAY":if("string"!==actualType)break;if(!validate(inferExpectation,argValue,inferExpectationValue))return THROW();break;case"IS-BOOL":if("string"!==actualType&&"boolean"!==actualType&&"number"!==actualType)break;if(!validate(inferExpectation,argValue,inferExpectationValue))return THROW();break;case"BETWEEN":case"BETWEEN-INCLUSIVE":if("number"!==actualType)break;if(!validate(inferExpectation,argValue,inferExpectationValue))return THROW();break;case"BETWEEN-BIGINT":case"BETWEEN-BIGINT-INCLUSIVE":if("bigint"!==actualType)break;if(!validate(inferExpectation,argValue,inferExpectationValue))return THROW();break;case"GREATER-THAN":case"GREATER-THAN-EQUAL":case"LESS-THAN":case"LESS-THAN-EQUAL":case"CHAR":case"INT8":case"UNSIGNED-CHAR":case"UCHAR":case"UINT8":case"SHORT":case"SHORT-INT":case"SIGNED-SHORT-INT":case"INT16":case"UNSIGNED-SHORT":case"UNSIGNED-SHORT-INT":case"USHORT":case"UINT16":case"SIGNED-INT":case"INT":case"INT32":case"UNSIGNED-INT":case"UINT":case"UINT32":if("number"!==actualType&&"string"!==actualType)break;if(!validate(inferExpectation,argValue,inferExpectationValue))return THROW();break;case"EXTENDS-ALL":case"EXTENDS":case"PROPS":if("object"!==actualType)break;if(!validate(inferExpectation,argValue,inferExpectationValue))return THROW();break;case"ARRAY-NOT-EMPTY":case"ARRAY-EMPTY":case"ARRAY-TYPES":if("array"!==actualType)break;if(!validate(inferExpectation,argValue,inferExpectationValue))return THROW();break;case"SIGNED-LONG":case"SIGNED-LONG-LONG":case"LONG":case"LONG-LONG":case"INT64":case"UNSIGNED-LONG":case"UNSIGNED-LONG-LONG":case"ULONG":case"UINT64":if("bigint"!==actualType&&"string"!==actualType)break;if(!validate(inferExpectation,argValue,inferExpectationValue))return THROW()}}}}}}}}module.exports=__webpack_exports__;